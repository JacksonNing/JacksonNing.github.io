<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>C++学习心得(一) | 既以歌声惊天下 何必起舞乱芳华</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/8.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">C++学习心得(一)</h1><a id="logo" href="/.">既以歌声惊天下 何必起舞乱芳华</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> Inicio</i></a><a href="/archives/"><i class="fa fa-archive"> Archivo</i></a><a href="/about/"><i class="fa fa-user"> Acerca de</i></a><a href="/atom.xml"><i class="fa fa-rss"> RSS</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">C++学习心得(一)</h1><div class="post-meta">Mar 22, 2019</div><div class="post-content"><p>C++是C的超集，也可以说C是C++的子集，因为C先出现。按常理说，C++编译器能够编译任何C程序，但是C和C++还是有一些小差别。例如C++增加了C不具有的关键字。这些关键字能作为函数和变量的标识符在C程序中使用，尽管C++包含了所有的C，但显然没有任何C++编译器能编译这样的C程序。<br>如何学习？<br>    面向过程思维转变成面向对象的思维<br>    一定要注重思考问题、思考概念、思考设计哲学<br>    多练习、多敲代码</p>
<p>C++对C语言的扩展知识<br>先看一个C++经典导学代码，求圆的面积和周长：</p>
<p>#include <iostream></iostream></p>
<p>using namespace std; //包名<br>class Circle<br>{<br>double radius ; //成员变量<br>public : //类的访问控制<br>void Set_Radius( double r ) { radius = r ; } //成员函数<br>double Get_Radius()  { return  radius ; } //通过成员函数设置成员变量<br>double Get_Girth()     { return  2 <em> 3.14f </em> radius ; } //通过成员函数获取成员变量<br>double Get_Area()     { return  3.14f <em> radius </em> radius ; }<br>} ;</p>
<p>int main()<br>{<br>Circle A, B ; //用类定义对象<br>A.Set_Radius( 6.23 ) ; //类的调用<br>cout &lt;&lt;”A.Radius = “&lt;&lt;A.Get_Radius() &lt;&lt;endl ;<br>cout &lt;&lt;”A.Girth = “&lt;&lt;A.Get_Girth() &lt;&lt;endl ;<br>cout &lt;&lt;”A.Area = “&lt;&lt;A.Get_Area() &lt;&lt;endl ;<br>B.Set_Radius( 10.5 ) ;<br>cout &lt;&lt;”B.radius = “&lt;&lt;B.Get_Radius() &lt;&lt;endl ;<br>cout &lt;&lt;”B.Girth=”&lt;&lt;B.Get_Girth() &lt;&lt;endl ;<br>cout &lt;&lt;”B.Area = “&lt;&lt;B.Get_Area() &lt;&lt;endl ;<br>return 0;<br>}<br>思考题：C是面向过程的，执行语句是一步一步执行的，也可以是函数之间的调用，那么上面的代码怎么执行？（面向对象的思维解决问题）<br>成员函数是否可以不要？为什么c++中设计了成员函数？<br>扩展知识总结：<br>一、命名空间总结<br>A)当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespace std；这样才能正确使用cout。若不引入using namespace std ,需要写std::cout。<br>B)c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。<br>C)C++命名空间的定义：namespace name {  …  }<br>D)using namespace NameSpaceA;<br>E)namespce定义可嵌套。<br>代码实战1：熟悉namespace用法</iostream></p>
<p>#include “namespace_demo.h”</p>
<p>#include <iostream><br>using namespace NameSpaceA;<br>int  main(){<br>    printf(“a = %d\n”, name);<br>printf(“a = %d\n”, NameSpaceB::age);</iostream></p>
<p>NameSpaceB::NameSpaceC::Teacher teacher;<br>teacher = {“aaa”, 3};</p>
<p>printf(“t1.name = %s\n”, teacher.name);<br>printf(“t1.age = %d\n”, teacher.age);</p>
<p>return 0;<br>}<br>二、常量 const int number = 100; 在c里面可以通过指针进行修改，但是在C++里面不行，这个和编译器有关系。<br>三、引用 int age = 18；int&amp; age2 = age；<br>引用概念：<br>    在C++中新增加了引用的概念。引用可以看作一个已定义变量的别名，引用的语法：Type&amp; name = var; 引用作为函数参数声明时不进行初始化。<br>    普通引用在声明时必须用其它的变量进行初始化，引用作为函数参数声明时不进行初始化。<br>    C++编译器在编译过程中使用常指针作为引用的内部实现，因此引用所占用的空间大小与指针相同。<br>指针和引用的区别？理解引用的真实含义？<br>代码分析：main.cpp中的testReference();testReferenceB();testPointerReference();<br>零碎的知识点<br>可变参数？看代码可变参数.cpp<br>Static关键字？C++怎么操作？静态属性在C++中一定要初始化，必须写int Student::age = 23；静态方法不能操作非静态成员。静态可以直接通过类名来操作。非静态可以操作静态。<br>对象的大小？1.对象的大小与结构体计算方式一致 2.static 静态变量和方法没有计算到类的大小里面3.C++类对象计算需要考虑成员变量大小，内存对齐、是否有虚函数、是否有虚继承等。4.类对象大小没有因为增加了静态成员而变化。因为静态成员是属于类成员共有的，不单独属于任何一个对象，对静态成员的存储不会选择在某个对象空间，而是存在于堆当中，因此不会对对象的大小造成影响。<br>Const:修饰类的函数 void test() const{} 主要是来修饰this指针不能被修改<br>Typedef：类型替换 typedef unsigned int u_int;   tt = 266;<br>迁移c的代码到c++：</p>
<p>#ifdef __cplusplus<br>extern “C”{</p>
<p>#endif<br>void func(int x,int y);</p>
<p>#ifdef __cplusplus<br>}</p>
<p>#endif<br>//__cplusplus 是由c++编译器定义的宏，用于表示当前处于c++环境<br>静态函数和静态成员怎么使用？ 代码静态.cpp<br>C++类和对象<br>学习c++一定要有面向对象的思维。我们从类的函数开始来梳理一个类是如何被定义？如何被初始化的？<br>类的构造函数：类的构造函数是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。<br>构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。<br>构造函数一般是被c++编译器自动调用，也可以被手动调用。<br>类的析构函数：C++中的类可以定义一个特殊的成员函数清理对象，这个特殊的成员函数叫做析构函数。析构函数没有参数也没有任何返回        类型的声明。析构函数在对象销毁时自动被调用。注意这个调用的时机。语法：～classname<br>什么时候析构函数被调用呢？<br>1，栈对象离开其作用域。 2，堆对象被手动 delete.<br>二个特殊的构造函数<br>1）默认无参构造函数<br>当类中没有定义构造函数时，编译器默认提供一个无参构造函数，并且其函数体为空<br>2）默认拷贝构造函数(对象)<br>3）当类中没有定义拷贝构造函数时，编译器默认提供一个默认拷贝构造函数，简单的进行成员变量的值复制。<br>拷贝构造函数：<br>拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。拷贝构造函数通常用于：<br>1）通过使用另一个同类型的对象来初始化新创建的对象。Teacher t = t2;<br>2）复制对象把它作为参数传递给函数。<br>3）复制对象，并从函数返回这个对象。<br>如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：<br>classname (const classname &amp;obj) { // 构造函数的主体 }<br>在这里，obj 是一个对象引用，该对象是用于初始化另一个对象的。<br>代码实战：类的初始化以及多种函数的使用。</p>
<p>#include <iostream></iostream></p>
<p>#include &lt;string.h&gt;</p>
<p>using namespace std;</p>
<p>class Student<br>{<br>public:<br>Student(int age,char <em>name)<br>    {<br>        printf(“构造函数执行\n”);<br>//this-&gt;name = name;<br>this-&gt;name = (char</em>)(malloc(sizeof(char) * 100));<br>strcpy(this-&gt;name,name);<br>this-&gt;age = age;<br>}</p>
<p>/<strong>注意这里的写法 有点像kotlin  赋值参数</strong>/<br>Student(char *name) : name(name) {<br>this-&gt;name = name;<br>}</p>
<p>Student() {<br>        printf(“空参构造函数执行\n”);<br>}</p>
<pre><code>~Student() //如果在对象内部堆内存上开辟了内存，一定要记得回收
</code></pre><p>{<br>        printf(“析构函数执行\n”);<br>free(this-&gt;name); //free 对应malloc</p>
<p>}<br>Student(const Student&amp; student)<br>    {<br>        printf(“对象的拷贝构造函数执行\n”);<br>this-&gt;name = student.name;<br>this-&gt;age = student.age-1; //方便测试<br>}</p>
<p>public:<br>int getAge()<br>    {<br>return this-&gt;age;<br>}</p>
<p>char* getName()<br>    {<br>return this-&gt;name;<br>}</p>
<p>void setAge(int age) {<br>Student::age = age;<br>}</p>
<p>void setName(char *name) {<br>Student::name = name;<br>}</p>
<p>private:<br>int age;<br>char* name;<br>};</p>
<p>//todo<br>//int main(){<br>//   //Student student; //第一种<br>//   //Student student1(33,”jesson”); //第二种<br>//   Student<em> student = new Student(33,”jesson”); //第三种<br>//   //Student</em> student = (Student*)malloc(sizeof(Student));//第四种<br>//   //student-&gt;setAge(100);<br>//   //student-&gt;setName(“jesson”);<br>//   delete(student); //注意delete 是回收new对象的<br>//   cout&lt;<student->getAge()&lt;&lt;endl;<br>//   cout&lt;<student->getName()&lt;&lt;endl;<br>//}</student-></student-></p>
<p>//——-拷贝构造函数——–<br>int main(){<br>Student student1(33,”jesson”);<br>Student a = student1;<br>cout&lt;&lt;a.getAge()&lt;&lt;endl;<br>}</p>
<p>struct Persron{<br>int age;<br>char* name;<br>};</p>
<p>//int main(){<br>//    Persron persron = {24,”jesson”};<br>//    Persron persron2 = persron; //这句话的意思是赋值，编译器的工作<br>//    cout&lt;&lt;&amp;persron&lt;&lt;”===”&lt;&lt;&amp;persron2&lt;&lt;endl;<br>//}</p>
<p>友元函数：类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。<br>class Box<br>{<br>   double width;<br>public:<br>   double length;<br>friend void printWidth( Box box );<br>   void setWidth( double wid );<br>};</p>
<p>#include <iostream><br>using namespace std;<br>class Box<br>{<br>   double width;<br>public:<br>   friend void printWidth( Box box );<br>   void setWidth( double wid );<br>}；<br>// 成员函数定义<br>void Box::setWidth( double wid )<br>{<br>    width = wid;<br>}</iostream></p>
<p>// 请注意：printWidth() 不是任何类的成员函数<br>void printWidth( Box box )<br>{<br>   /<em> 因为 printWidth() 是 Box 的友元，它可以直接访问该类的任何成员 </em>/<br>   cout &lt;&lt;”Width of box : “&lt;&lt; box.width &lt;&lt;endl;<br>}</p>
<p>// 程序的主函数<br>int main( )<br>{<br>   Box box;<br>   // 使用成员函数设置宽度<br>   box.setWidth(10.0)；<br>   // 使用友元函数输出宽度<br>   printWidth( box );<br>   return 0;<br>}<br>操作符重载：C++ 运算符重载，函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作；运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能；实际上，我们已经在不知不觉中使用了运算符重载；例如，+号可以对不同类型（int、float 等）的数据进行加法操作；&lt;&lt;既是位移运算符，又可以配合 cout 向控制台输出数据；C++ 本身已经对这些运算符进行了重载。</p>
<p>#include “运算符重载.h”</p>
<p>#include <cstdio><br>using namespace std;<br>void 运算符重载::print() const {<br>    printf(“%g + %g\n”, m_real, m_imag);<br>}<br>运算符重载 运算符重载::operator+(const 运算符重载 &amp;A) const {<br>    return 运算符重载(m_real + A.m_real, m_imag + A.m_imag);<br>}<br>int main() {<br>    运算符重载 A(1.24, 5.7), B(4, 3.14), C;<br>    C = A + B;<br>    C.print();<br>    return 0;<br>}</cstdio></p>
<p>C++继承和派生<br>派生类的目的是为了发展，派生类继承了基类的成员，实现了原有代码的重用，这只是一部分，而代码的扩充才是最主要的，只有通过添加新的成员，加入新的功能，类的派生才有实际意义。<br>以下是两种典型的使用继承的场景：<br>1) 当你创建的新类与现有的类相似，只是多出若干成员变量或成员函数时，可以使用继承，这样不但会减少代码量，而且新类会拥有基类的所有功能；<br>2) 当你需要创建多个类，它们拥有很多相似的成员变量或成员函数时，也可以使用继承；可以将这些类的共同成员提取出来，定义为基类，然后从基类继承，既可以节省代码，也方便后续修改成员；<br>因为时间问题，我这里不做详细笔记了，大家参考我的代码 整理下。</p>
<p>C++多态与虚函数<br>C++多态与虚函数，多态（Polymorphism）是面向对象（Object-Oriented，OO）思想”三大特征”之一，其余两个分别是封装（Encapsulation）和继承（Inheritance）–可见多态的重要性；或者说，不懂得什么是多态就不能说懂得面向对象。<br>多态是一种机制、一种能力，而非某个关键字；它在类的继承中得以实现，在类的方法调用中得以体现；</p>
<p>C++模版<br>C++是一门强类型语言，所以无法做到像动态语言（python javascript）那样子，编写一段通用的逻辑，可以把任意类型的变量传进去处理。泛型编程弥补了这个缺点，通过把通用逻辑设计为模板，摆脱了类型的限制，提供了继承机制以外的另一种抽象机制，极大地提升了代码的可重用性。<br>模板定义本身不参与编译，而是编译器根据模板的用户使用模板时提供的类型参数生成代码，再进行编译，这一过程被称为模板实例化。用户提供不同的类型参数，就会实例化出不同的代码。<br>普通函数模板：<br>template<typename t=""><br>int compare(const T&amp; left, const T&amp; right) {<br>    if (left &lt; right) {<br>        return -1;<br>    }<br>    if (right &lt; left) {<br>        return 1;<br>    }<br>    return 0;<br>}<br>compare<int>(1, 2); //使用模板函数<br>成员函数模板：<br>class Printer {<br>public:<br>    template<typename t=""><br>    void print(const T&amp; t) {<br>        cout &lt;&lt; t &lt;&lt;endl;<br>    }<br>};<br>Printer p;<br>p.print<const char*="">(“abc”); //打印abc<br>模版类：<br>template<class t，class="" b=""> 定义一个模板类<br>为类定义一种模式。使得类中的某些数据成员、默写成员函数的參数、某些成员函数的返回值，能够取随意类型<br>常见的 容器比如 向量 vector <int> 或 vector <string> 就是模板类。<br>详见代码 Seqlist<br>C++ STL<br>C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。<br>组件    描述<br>容器（Containers）    容器是用来管理某一类对象的集合。C++ 提供了各种不同类型的容器，比如 deque、list、vector、map 等。<br>算法（Algorithms）    算法作用于容器。它们提供了执行各种操作的方式，包括对容器内容执行初始化、排序、搜索和转换等操作。<br>迭代器（iterators）    迭代器用于遍历对象集合的元素。这些集合可能是容器，也可能是容器的子集。</string></int></class></const></typename></int></typename></p>
<p>在数据存储上，有一种对象类型，它可以持有其它对象或指向其它对像的指针，这种对象类型就叫做容器。很简单，容器就是保存其它对象的对象，当然这是一个朴素的理解，这种“对象”还包含了一系列处理“其它对象”的方法。<br>容器的分类：<br>1、顺序容器：是一种各元素之间有顺序关系的线性表，是一种线性结构的可序群集。顺序性容器中的每个元素均有固定的位置，除非用删除或插入的操作改变这个位置。顺序容器的元素排列次序与元素值无关，而是由元素添加到容器里的次序决定。顺序容器包括：vector(向量)、list（列表）、deque（队列）。<br>  2、关联容器：关联式容器是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，也就是说元素在容器中并没有保存元素置入容器时的逻辑顺序。但是关联式容器提供了另一种根据元素特点排序的功能，这样迭代器就能根据元素的特点“顺序地”获取元素。元素是有序的集合，默认在插入的时候按升序排列。关联容器包括：map（集合）、set（映射）、multimap（多重集合）、multiset（多重映射）。<br>  3、容器适配器：本质上，适配器是使一种不同的行为类似于另一事物的行为的一种机制。容器适配器让一种已存在的容器类型采用另一种不同的抽象类型的工作方式实现。适配器是容器的接口，它本身不能直接保存元素，它保存元素的机制是调用另一种顺序容器去实现，即可以把适配器看作“它保存一个容器，这个容器再保存所有元素”。STL 中包含三种适配器：栈stack 、队列queue 和优先级队列priority_queue 。<br>容器类自动申请和释放内存，因此无需new和delete操作。</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/2019/03/22/C学习心得-一/">C学习心得(一)</a><a class="next" href="/2019/02/01/关于IM通讯的研究/">关于IM通讯的研究</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://yoursite.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> Categorías</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> Etiquetas</i></div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> Recientes</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/03/22/C学习心得-一/">C学习心得(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/03/22/C-学习心得-一/">C++学习心得(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/02/01/关于IM通讯的研究/">关于IM通讯的研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/万能接口的使用/">万能接口的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/31/对事件分发机制的一些理解/">对事件分发机制的一些理解</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/28/手写EventBus框架/">手写EventBus框架</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/25/安卓跨进程间通讯的研究/">安卓跨进程间通讯的研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/14/安卓性能优化工具/">安卓性能优化工具</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/10/LRU算法的研究/">LRU算法的研究</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/01/02/2018总结之Gradle/">2018总结之Gradle</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> Blogroll</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2019 <a href="/." rel="nofollow">既以歌声惊天下 何必起舞乱芳华.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/3.3.5/jquery.fancybox.min.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>